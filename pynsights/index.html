<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <script src="https://unpkg.com/three"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://unpkg.com/three-spritetext"></script>
    <script src="https://unpkg.com/three/examples/js/renderers/CSS2DRenderer.js"></script>
    <style>
        body {
            background-color: black;
        }
        .node-label {
            font-size: 12px;
            padding: 1px 4px;
            border-radius: 4px;
            background-color: rgba(0,0,0,0.5);
            user-select: none;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
        }
        .log {
            position: absolute;
            top: 40px;
            left: 10px;
            color: grey;
            height: 20px;
            overflow: hidden;
            font-size: 17px;
            font-family: Arial, Helvetica, sans-serif;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            margin-right: 8px;
        }
        .paused {
            display: none;
            position: absolute;
            top: 0px;
            padding: 300px;
            width: 100%;
            height: 100%;
            color: white;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 30px;
            background-color: rgba(0,0,0,0.8);
        }
        #timemax {
            display: inline-block;
            margin-right: 21px;
        }
        #timelinetime {
            z-index: 1001;
            position: absolute;
            top: 102px;
            display: block;
            color: orange;
            background-color: black;
        }
        #timeline {
            position: absolute;
            top: 40px;
            left: 0;
            width: calc(100% - 24px);
            height: 100px;
            margin-left: 12px;
            margin-right: 12px;
            background-color: black;
            border: 1px solid white
        }
        #timelinehandle {
            position: relative;
            top: 0;
            left: 0;
            width: 2px;
            height: 100px;
            background-color: orange;
        }
        #timelinehoverconnector {
            position: absolute;
            z-index: 1000;
            top: -20px;
            left: 0;
            width: 0px;
            border: 1px solid orange;
            height: 0;
        }
        #timelinehover {
            position: absolute;
            z-index: 1000;
            top: -20px;
            left: 20px;
            padding: 4px;
            color: orange;
            border-width: 0;
        }
        .timelinemarker {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 3px;
        }
        #timelineplay {
            display: inline-block;
            color: white;
            margin-right: 4px;
            text-decoration: underline;
            cursor: pointer;
            background-color: black;
        }
        .timelineannotation {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 3px;
            background-color: lightgrey;
            border: 2px solid red;
        }
        .timelineannotationtext {
            position: absolute;
            top: 130px;
            color: white;
            font-size: 12px;
            font-family: Arial, Helvetica, sans-serif;
            background-color: black;
        }
        .timelineannotationline {
            position: absolute;
            top: 0;
            width: 5px;
            height: 100%;
            border: 0px solid rgb(85, 85, 85);
            border-left-width: 1px;
        }
        .timelinemarker:hover {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 6px;
        }
    </style>
    <body>
        <div id="graph-container">
            <div id="3d-graph"></div>
        </div>
        <div id="paused" class="paused">Pauzing to save GPU cycles...</div>
        <div id="timelinehover"></div>
        <div id="timelinehoverconnector"></div>
        <div id="timeline">
            <div id="timelinehandle"></div>
            <div id="timelinetime">0</div>
        </div>
        <div id="timemax">0</div>
        <div class="controls">
            <div id="timelineplay">⏸</div>
            <input type="checkbox" id="bloom"></input>
            <label for="bloom">Bloom</label>
            <input type="checkbox" id="toplevel"></input>
            <label for="toplevel">Toplevel</label>
            <input type="checkbox" id="counts"></input>
            <label for="counts">Counts</label>
            <input type="checkbox" id="dots"></input>
            <label for="dots">Dots</label>
        </div>
        <script type="module">

import { UnrealBloomPass } from 'https://cdn.skypack.dev/three/examples/jsm/postprocessing/UnrealBloomPass.js';

const PARTICLE_SIZE = 4;
const PARTICLE_COLOR_SYSTEM = 'white';
const PARTICLE_COLOR_SELF = 'orange';

const settings = {
    toplevel: localStorage.getItem("toplevel") == "true",
    counts: localStorage.getItem("counts") != "false",
    dots: localStorage.getItem("dots") != "false",
    bloom: localStorage.getItem("bloom") == "true",
};
const sprites = {};
const Graph = createGraph();
const linkMap = {};
const nodeMap = {};

var newNodes = {}
var newLinks = {}
var liveLinks = {}
var graphData = Graph.graphData();
var playIndex = 0;
var timelineMarkerCount = 0;

const modulenames = /*MODULENAMES*/ [];
const callsites = /*CALLSITES*/ [];
const calls = /*CALLS*/ [];
const cpus = /*CPUS*/ [];
const annotations = /*ANNOTATIONS*/ [];
const duration = /*DURATION*/ 0;

const colors = [];
const colorValues = [ 52, 192, 256 ];
for (const r of colorValues) {
    for (const g of colorValues) {
        for (const b of colorValues) {
            colors.push("rgb(" + r + "," + g + "," + b + ")" );
        }
    }
}
colors.shift(); // remove lightgrey
function getColor(group) {
    return colors[group.hashCode() % colors.length];
}

var PLAY_SECTION_DURATION = 50;

$(window).resize(() => location.reload());
$("#timeline")
    .prepend($("<canvas>")
        .attr("id", "timelinecanvas")
        .attr("width", $("#timeline").width())
        .attr("height", $("#timeline").height())
    );

document.title = "Pynsights";

function timelineClick(event) {
    stopPlaying();
    const x = event.pageX - $("#timeline").position().left - 24;
    const gotoWhen = x * duration / ($("#timeline").width() - 24);
    playIndex = 0;
    while (playIndex < calls.length) {
        // linear search, consider binary search for large recordings...
        if (getWhen(playIndex) > gotoWhen) {
            setTimeout(startPlaying, 1000);
            return updateTimeline(calls[playIndex-1]);
        }
        playIndex++;
    }
}
$('#timemax').text((duration / 1000).toFixed(1) + "s");
$('#timeline').click((event) => {
    stopPlaying();
    setTimeout(function () { timelineClick(event); }, 1)
});
$('#timelineplay').click((event) => {
    if (!isPlaying()) {
        startPlaying();
    } else {
        stopPlaying();
    }
    event.stopPropagation();
});

String.prototype.hashCode = function() {
    const len = this.length;
    var hash = 0;
    for (var n = 0; n < len; n++) {
        hash  = ((hash << 5) - hash + this.charCodeAt(n)) << 0;
    }
    return hash + 2147483647 + 1;
};

function addCallsToTimeline(index) {
    if (index >= calls.length) return;
    const end = Math.min(calls.length, index + 500);
    var markersToAdd = 21;
    while (index < end) {
        if (markersToAdd-- > 0) {
            addCallToTimeline(calls[index]);
        }
        const lastWhen = calls[index++][0];
        while (index < end && calls[index][0] < lastWhen + 100) {
            index += 1;
        }
    }
    setTimeout(function() { addCallsToTimeline(index); }, 1);
}

function drawTimelineChartLine(context, x1, y1, x2, y2, color) {
    context.beginPath(); 
    context.strokeStyle = color;
    context.lineWidth = 4;
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.stroke();
    console.log("line", x1, y1, x2, y2)
}

function addCpusToTimeline() {
    const canvas = document.getElementById('timelinecanvas');
    const context = canvas.getContext('2d');
    const height = $("#timeline").height();
    var lastX = 0, lastY = height;
    for (const cpuScore of cpus) {
        const [when, cpu, systemCpu] = cpuScore;
        console.log(systemCpu)
        const x = getX(when);
        const y = height - 2 - systemCpu * height / 100;
        drawTimelineChartLine(context, lastX, lastY, x+1, y, "#005000")
        lastX = x;
        lastY = y;
    }
}

    
function addCallToTimeline(call) {
    const timeline = $("#timeline");
    const [when, callsiteIndex, count] = call;
    const x = getX(when);
    const [source, target] = callsites[callsiteIndex];
    const y = getModule(source).hashCode() % 100;
    var color = getColor(getGroup(source));
    const title = "Call from " + 
        getGroup(source) + "." + getModule(source) + " to " + 
        getGroup(target) + "." + getModule(target);
    $("<div>")
        .attr("module", settings.toplevel ? getGroup(source) : getModule(source))
        .addClass("timelinemarker")
        .css({
            left: x,
            top: y,
            backgroundColor: color,
        })
        .hover(function(event) {
            updateTimelineHover(event, $(this), title);
        })
        .appendTo(timeline);
}

function getX(when) {
    return Math.round(when * ($("#timeline").width() - 24) / duration) + 12;
}

function updateTimeline(call) {
    const [when, callsite, count] = call;
    $("#timelinehandle")
        .css("left", getX(when));
    $("#timelinetime")
        .css("left", getX(when))
        .text((when / 1000).toFixed(1) + "s");
}

function annotateTimeline(index) {
    if (index >= annotations.length) return;
    const end = Math.min(annotations.length, index + 10);
    while (index < end) {
        annotateTimelineMarker(annotations[index++]);
    }
    setTimeout(function() { annotateTimeline(index); }, 1);
}

function annotateTimelineMarker(annotation) {
    const [when, message] = annotation;
    const enterOrExit = message.match(/^Enter |^Exit /);
    const y = enterOrExit ? 105 : 120;
    function hover(event) {
        updateTimelineHover(event, $(this), message);
    }
    $("<div>")
        .addClass("timelineannotationline")
        .css({
            left: getX(when) + 4,
            height: y + 10,
        })
        .hover(hover)
        .appendTo(timeline);
    $("<div>")
        .addClass("timelineannotationtext")
        .css({
            left: getX(when) + 4,
            top: y,
        })
        .text(message)
        .appendTo(timeline);
}

function updateTimelineHover(event, marker, text) {
    const x = marker.offset().left + marker.width() / 2;
    const width = $("body").width();
    $("#timelinehover")
        .css({
            left: x > width / 2 ? x - $("#timelinehover").width() : x, 
            top: 170,
        })
        .text(text);
    $("#timelinehoverconnector")
        .css({
            left: x,
            top: event.pageY,
            height: 168 - event.pageY,
        });
    event.stopPropagation();
}

$("#toplevel")
    .prop("checked", settings.toplevel)
    .on("change", () => {
        settings.toplevel = $("#toplevel").is(":checked");
        localStorage.setItem("toplevel", settings.toplevel);
        location.reload();
    });
$("#bloom")
    .prop("checked", settings.bloom)
    .on("change", () => {
        settings.bloom = $("#bloom").is(":checked");
        localStorage.setItem("bloom", settings.bloom);
        location.reload();
    });
$("#counts")
    .prop("checked", settings.counts)
    .on("change", () => {
        settings.counts = $("#counts").is(":checked");
        localStorage.setItem("counts", settings.counts);
        Object.values(sprites).forEach(sprite => sprite.text = settings.counts ? `${count}` : "");
    });
$("#dots")
    .prop("checked", settings.dots)
    .on("change", () => {
        settings.dots = $("#dots").is(":checked");
        localStorage.setItem("dots", settings.dots);
    });

function createGraph() {
    const graph = ForceGraph3D({
        extraRenderers: [new THREE.CSS2DRenderer()]
    })
    (document.getElementById('3d-graph'))
        .nodeThreeObject(node => {
            const sprite = new SpriteText(node.id);
            sprite.material.depthWrite = false; // make sprite background transparent
            sprite.color = getColor(node.group);
            sprite.textHeight = 8;
            return sprite;
        })
        .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;
        })
        .linkDirectionalParticleColor(link => link.particleColor)
        .linkDirectionalParticleSpeed(0.01)
        .linkDirectionalParticleWidth(PARTICLE_SIZE)
        .linkThreeObjectExtend(true)
        .linkCurvature(0.1)
        .linkOpacity(settings.bloom ? 0.2 : 0.3)
        .linkThreeObject(link => {
            const sprite = new SpriteText(settings.counts ? `${link.count}` : "");
            sprite.color = '#999';
            sprite.textHeight = 5;
            sprites[link.key] = sprite;
            return sprite;
        })
        .linkPositionUpdate((sprite, { start, end }) => {
            const middlePos = Object.assign(...['x', 'y', 'z'].map(c => ({
                [c]: start[c] + (end[c] - start[c]) * 2 / 5 // calc middle point
            })));
            Object.assign(sprite.position, middlePos);
        });

    if (settings.bloom) {
        const bloomPass = new UnrealBloomPass();
        bloomPass.strength = 2;
        bloomPass.radius = 1;
        bloomPass.threshold = 0.1;
        graph.postProcessingComposer().addPass(bloomPass);
    }

    graph.d3Force('charge').strength(settings.toplevel ? -500 : -200);
    return graph;
}

function updateGraph() {
    if (!Object.values(newLinks).length) return;
    const { nodes, links } = Graph.graphData();
    Graph.graphData({
        nodes: [...nodes, ...Object.values(newNodes)],
        links: [...links, ...Object.values(newLinks)],
    });
    graphData = Graph.graphData();
    newLinks = {};
    newNodes = {};
}

function updateLinks() {
    Object.values(liveLinks).map(updateLink);
    liveLinks = {};
}

function getModule(index) {
    return modulenames[index][settings.toplevel ? 0 : 1];
}

function getGroup(index) {
    return modulenames[index][0];
}

function linkKey(source, target) {
    return `${source}>${target}`;
}

function addNode(index) {
    const module = getModule(index);
    if (!nodeMap[module]) {
        newNodes[module] = nodeMap[module] = {
            id: getModule(index),
            group: getGroup(index),
        };
    }
    return nodeMap[module];
}

function addLink(when, sourceIndex, targetIndex) {
    const source = addNode(sourceIndex);
    const target = addNode(targetIndex);
    const key = linkKey(source.id, target.id);
    var link = linkMap[key];
    if (link === undefined) {
        link = {
            source: source.id,
            target: target.id,
            key,
            value: 5,
            count: 0,
            color: "white",
            particleColor: getColor(source.group),
        };
        newLinks[key] = link;
        linkMap[key] = link;
    }
    link.count++;
    liveLinks[key] = { when, link };
}

function shouldRender() {
    if (document.hidden) return false;
    return true;
}

function updateLink(event) {
    const { when, link } = event;
    if (settings.dots) {
        Graph.emitParticle(link);
    }
    if (settings.counts && sprites[link.key]) {
        sprites[link.key].text = `${link.count}`;
    }
}

function getWhen(index) {
    const [ when, _callsite, _count ] = calls[index];
    return when;
}

function addToGraph(call) {
    const [when, callsiteIndex, count] = call;
    const [source, target] = callsites[callsiteIndex];
    if (getGroup(source) == "bootstrap") return;
    if (getGroup(target) == "bootstrap") return;
    addLink(when, source, target);
}

function findChunkEnd(n) {
    const start = getWhen(n);
    while (n < calls.length && getWhen(n) - start < PLAY_SECTION_DURATION) {
        n++;
    }
    return n;
}

function getTimeMillis() {
    return new Date().getTime();
}

function initTimeline() {
    annotateTimeline(0);
    addCallsToTimeline(0);
    addCpusToTimeline();
}

function playCalls() {
    const clockStart = getTimeMillis();
    const whenStart = getWhen(playIndex);
    function playChunk() {
        if (!isPlaying()) return;
        const chunkEnd = findChunkEnd(playIndex);
        while (isPlaying() && playIndex < chunkEnd) {
            addToGraph(calls[playIndex++]);
        }
        updateGraph();
        if (playIndex >= calls.length) {
            stopPlaying();
            playIndex = 0;
        } 
        else {
            const clockNow = getTimeMillis();
            const whenNow = getWhen(playIndex);
            const clockDuration = clockNow - clockStart;
            const whenDuration = whenNow - whenStart;
            setTimeout(playChunk, Math.min(500, Math.max(1, whenDuration - clockDuration)));
        }
        updateTimeline(calls[playIndex]);
    }
    setTimeout(playChunk, 1);
}

function isPlaying() {
    return $("#timelineplay").text() == "⏸️";
}

function startPlaying() {
    $("#timelineplay").text("⏸️");
    playCalls();
}

function stopPlaying() {
    $("#timelineplay").text("▶️");
}

setInterval(updateLinks, 1000);
initTimeline();
startPlaying();

          </script>
    </body>
</head>